_update_sh_prompt () {
## Save $? early, we'll need it later
local exit="$?"  

## define some colors
Color_Off="\[\033[0m\]"       # Text Reset

Black="\[\033[00;30m\]"
DarkGrey="\[\033[01;30m\]"
Red="\[\033[00;31m\]"
LightRed="\[\033[01;31m\]"
Green="\[\033[00;32m\]"
LightGreen="\[\033[01;32m\]"
Brown="\[\033[00;33m\]"
Yellow="\[\033[01;33m\]"
Blue="\[\033[00;34m\]"
LightBlue="\[\033[01;34m\]"
Cyan="\[\033[00;36m\]"
LightCyan="\[\033[01;36m\]"
Purple="\[\033[00;35m\]"
LightPurple="\[\033[01;35m\]"
LightGrey="\[\033[00;37m\]"
White="\[\033[01;37m\]"

Time12h="\T"
Time24h="\t"
Time12a="\@"
PathShort="\w"
PathFull="\W"
NewLine="\n"
Jobs="\j"
sHostname="\h"
path=" $LightBlue$PathShort$Color_Off\$"

if [ "$UID" = "0" ]; then
    u="$Red\u$ColorOff";
else
    u="$Green\u$ColorOff";
fi

## Initial prompt
_prompt="$u@$Green$sHostname$Color_Off";

# Set this in your .bashrc_local
SVNP_HUGE_REPO_EXCLUDE_PATH=""

## Color git status if any
git_branch=`__git_ps1 "(%s)"`
svn_branch=`__svn_rev`
if [ -n "$git_branch" ] ; then
    git_prompt $git_branch
fi
if [ -n "$svn_branch" ] ; then
    svn_prompt
fi

export PS1="$_prompt$git_branch$svn_branch$path ";
}

git_prompt () {
    git_branch=${1}
    if [ -n "$git_branch" ] ; then
	if [ -z "$_dumb_prompt" ]; then
	    git status --porcelain | perl -ne 'exit(1) if /^ /; exit(2) if /^[?]/'
	    case "$?" in
		"0" )  git_branch=" $Green$git_branch$Color_Off"; path=" $Yellow$PathShort$Color_Off\$";; 
		"1" )  git_branch=" $Red$git_branch$Color_Off"; path=" $Yellow$PathShort$Color_Off\$";; 
		"2" )  git_branch=" $Yellow$git_branch$Color_Off"; path=" $Yellow$PathShort$Color_Off\$";;
		"130" ) git_branch=" $White$git_branch$Color_Off"; path=" $LightBlue$PathShort$Color_Off\$"; _dumb_prompt=1 ;; 
		esac
	else
	    git_branch=" $White$git_branch$Color_Off"; path=" $LightBlue$PathShort$Color_Off\$"
	fi
    fi
}

svn_prompt () {
    case `__svn_clean` in
	"0")	svn_branch=" $Green($(basename $(__svn_repo)):$(__svn_rev))$Color_Off"; path=" $Yellow$PathShort$Color_Off\$";;
	"1")	svn_branch=" $Red($(basename $(__svn_repo)):$(__svn_rev))$Color_Off"; path=" $Yellow$PathShort$Color_Off\$";;
    esac
}


# SVN Part - Copyright (C) 2008 Eric Leblond

# List of path to exclude from recursive status
# Explanation of following regexp:
# Exclude all directories under inl-svn, the nufw-svn directory, and
# all directories ending by /tags par /branches
# You can set it as environnement variable
if [ ! $SVNP_HUGE_REPO_EXCLUDE_PATH ]; then
    SVNP_HUGE_REPO_EXCLUDE_PATH="/tags$|/branches$"
fi

# Set SVNP_HAVE_HUGE_REPO if you have huge repository
# This will disable recursion when searching status
# and speed things a lot (but feature is less interessant).
# You can also look at the HUGE_REPO_EXCLUDE_PATH option

__svn_rev ()
{
    LANG='C' svn info 2>/dev/null | awk '/Revision:/ {print $2; }'
}

__svn_last_changed ()
{
    LANG='C' svn info 2>/dev/null | awk '/Last Changed Rev:/ { print $4;}'
}

__svn_repo ()
{
    LANG='C' svn info 2>/dev/null | awk '/Repository Root:/ {print $3; }'
}

__svn_clean ()
{
    if [ $SVNP_HAVE_HUGE_REPO ]; then
	HUGE_REPO=" -N ";
    else
	pwd | egrep -q $SVNP_HUGE_REPO_EXCLUDE_PATH && HUGE_REPO=" -N "
    fi
    STATE=$(LANG='C' svn $HUGE_REPO status 2>/dev/null | grep "^[MA]" | wc -l)
    if [ $STATE == 0 ]; then
	echo "0"
    else
	echo "1"
    fi
}
__svn_remote_clean ()
{
    if [ $SVNP_HAVE_HUGE_REPO ]; then
	HUGE_REPO=" -N ";
    else

dumb_prompt () {
    _dumb_prompt=1
}

smart_prompt () {
    unset _dumb_prompt
}

_update_py_prompt () {
    export PS1="$( $HOME/.powerline-shell.py $? 2> /dev/null)"
}

if [ -n "$PS1" ] ; then
    if [ -x $HOME/.powerline-shell.py ] && [ -x $(which python) ]; then
	PROMPT_COMMAND='_update_py_prompt'
    else
	PROMPT_COMMAND='_update_sh_prompt'
    fi
    export PROMPT_COMMAND
fi
